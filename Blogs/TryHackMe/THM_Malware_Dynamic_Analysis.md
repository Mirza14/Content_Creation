# Malware Dynamic Analysis Learning Objectives

- Sandboxing and how to use sandbox for Malware Analysis.
- Components of a Sandbox and how to create one for yourself.
- Using Windows ProcMon to monitor processes activity.
- Using Windows API Logger and API Monitor to identify API Calls made by malware.
- Using Windows ProcExp to identify if a process is modified maliciously.
- Using RegShot to track Windows registry changes made by malware.

## What is Malware Dynamic Analysis and why do we have to perform Dynamic Analysis

- Malware is simply put, a malicious software. It can use it's techniques to evade it's features wherever it's running. However, no matter how good malware tries to hides it's features, it's primary purpose is to execute it. When that happens, it certainly leave footprints that an Analyst can use to identify whether or not it's malicious.
- Dynamic Analysis is to analyze those traces malware leaves when it's running.

### Sandboxing

- In all the malware analysis rooms, it has been emphasized that malware should only be analyzed in a controlled environment, ideally a virtual machine. However, this becomes increasingly important for the dynamic analysis of malware. The primary concern regarding performing static analysis on malware in a live environment is an accidental execution, but we intentionally execute malware in a dynamic analysis scenario. Below are the 4 steps to create a sandbox:
- An isolated machine, ideally a virtual machine, that is not connected to live or production systems and is dedicated to malware analysis.
- The ability of the isolated or virtual machine to save it's initial clean state and revert to that state once malware analysis is complete. This functionality is often called creating and reverting a snapshot. We will need to revert to the original clean state before analyzing a new malware so that infection from the previous malware doesn't contaminate the analysis of the next one.
- Monitoring tools that help us analyze the malware while it's executing inside the Virtual Machine. These tools can be automated, as we see in automated sandboxes, or they can be manual, requiring the analyst to interact while performing analysis.
- A file-sharing mechanism that can be used to introduce the malware into the Virtual Machine and sends the analysis data or reports out to us. Often, shared directories or network drives are used for this purpose. However, we must be careful that the shared directory is unmounted when executing the malware, as the malware might infect all the files. This is especially true of ransomware, which might encrypt all shared drives or directories.

#### Malware Investigation using Process Monitor (ProcMon)

- Process Monitor is one of the Sysinternals utilities to analyze processes in malware's activities.
![Check the image for your reference](/Blogs/Images/image11.png)
- Number 1 - Open and Save options. These options are for opening a file that contains ProcMon events or saving the events to a supported file.
- Number 2 - Clear option. This option clears all the events currently being shown by ProcMon. It is good to clear the events once we execute a malware sample of interest to reduce noise.
- Number 3 - Filter option, which gives us further control over the events shown in the ProcMon window.
- Number 4 - These are toggles to turn off or on Registry, FileSystem, Network, Process/Thread, and Profiling events.
- *Filtering Events* - ProcMon allows easy filtering of events from the events window itself. If we right-click on the process column on the process of our choice, a pop-up menu opens up. We can see different options in the pop-up menu. Some of these options are related to filtering. For example, if we choose the option Include **Explorer.EXE**, ProcMon will only show events with Process Name Explorer.EXE. If we choose the option Exclude **Explorer.EXE**, it will exclude Explorer.EXE from the results.
![Check the image for your reference](/Blogs/Images/image12.png)
- As seen in the screenshot above, when we right-click on an event, we can filter in/out an event. Similarly, we can add more filters to the results until we narrow down the results to the events of our interest. If we choose the Include **Explorer.EXE** and Include **CreateFile** events, ProcMon will only show us CreateFile events triggered by Explorer.EXE.
![Check the image for your reference](/Blogs/Images/image13.png)
- *Advanced Filtering* - ProcMon also allows us to implement advanced filters. In the menu marked as number 3 in the first image in this task, we can see the option for filtering. When we click on this option, we see the following window pop up.
![Check the image for your reference](/Blogs/Images/image14.png)
- *Process Tree* - ProcMon also allows us to view all the existing processes in a parent-child relationship, forming a process tree. This option helps identify the parents and children of different processes. As shown by ProcMon, an example process tree can be seen below.
![Check the image for your reference](/Blogs/Images/image15.png)

1. Execute the sample malware `1.exe` using ProcMon. What is the first URL on which a network connection is made?
![Check the image for your reference](/Blogs/Images/image16.png)

2. What network operation is performed on the above-mentioned URL?
![Check the image for your reference](/Blogs/Images/image16.png)

3. What is the name with the complete full path of the first process created by this sample?
![Check the image for your reference](/Blogs/Images/image17.png)

##### Malware Investigation using API Logger and API Monitor

- The Windows OS abstracts the hardware and provides an Application Programmable Interface (API) for performing all tasks. For example, there is an API for creating files, an API for creating processes, an API for creating and deleting registries and so on. Therefore, one way to identify malware behaviour is to monitor which APIs a malware calls. The names of the APIs are generally self-explanatory. However, ([Microsoft Documentation](https://learn.microsoft.com/en-us/windows/win32/api/)) can be referred to for finding information about the APIs.
- *API Logger* - The API Logger is a simple tool that provides basic information about APIs called by a process.
- To open a new process, we can click the highlighted three-dot menu. When clicked, a file browser allows us to select the executable for which we want to monitor the API calls. Once we select the executable, we can click 'Inject & Log' to start the API logging process. We will see the log of API calls in the lower pane, as seen in the picture below. In the upper pane, we see the running processes and their PIDs.
![Check the image for your reference](/Blogs/Images/image18.png)
- *API Monitor* - The API Monitor provides more advanced information about a process's API calls.
![Check the image for your reference](/Blogs/Images/image19.png)
- Number 1 - Filter for the API group we want to monitor. For example, we have a group for 'Graphics and Gaming' related APIs, another for 'Internet' related APIs and so on. API Monitor will only show us APIs from the group we select from this menu.
- Number 2 - The processes being monitored for API calls. We can click the 'Monitor New Process' option to start monitoring a new process.
- Number 3 - Shows the API call, the Module, the Thread, Time, Return Value, and any errors. We can monitor this tab for APIs called by a process.
- Number 4 - Shows running processes that API Monitor can monitor.
- Number 5 - Shows the Parameters of the API call, including the values of those Parameters before and after the API calls.
- Number 6 - Shows the Hex buffer of the selected value.
- Number 7 - Call Stack of the process.
- Number 8 - Shows the Output.
- To understand it better, let's open a process in API Monitor. When we click the 'Monitor New Process' option in Tab 2, we see the following option:
![Check the image for your reference](/Blogs/Images/image20.png)
- In this menu, we can select the Process from a path, any arguments the process takes, the directory from where we want to start the process, and the method for attaching API Monitor. We can ignore the 'Arguments' and 'Start in' options if we don't have any arguments for the process and want to start it from the path where it is already located in. Once we open a process, we see the tabs populate as seen in the following image.
![Check the image for your reference](/Blogs/Images/image21.png)
- In Tab 1, we see that we have selected all values so that we can monitor all the API calls.
- In Tab 2, we see the path of the process we are monitoring.
- In Tab 3, we see a summary of the API calls. The highlighted API call can be seen as RegOpenKeyExW.  Hence we know that the process tried to open a registry key. We see that the API call returns an error, which we can see in the 'Return Value' field of this tab, and the error details can be found in this tab's 'Error' field.
- Tab 5 shows the parameters of the API call from before and after the API call was made.
- Tab 6 shows the selected value in Hex.
- Tab 7 shows the Call Stack of the process.

1. The sample `~Desktop\samples\1.exe` creates a file in the `C:\ directory`. What is the name with the full path of this file?
![Check the image for your reference](/Blogs/Images/image22.png)

2. What API is used to create this file?
![Check the image for your reference](/Blogs/Images/image22.png)

3. In Question 1 of the previous task, we identified a URL to which a network connection was made. What API call was used to make this connection?
![Check the image for your reference](/Blogs/Images/image23.png)

4. We noticed in the previous task that after some time, the sample's activity slowed down such that there was not much being reported against the sample. Can you look at the API calls and see what API call might be responsible for it?
![Check the image for your reference](/Blogs/Images/image24.png)

###### Malware Investigation using Process Explorer

- *Process Explorer* - Pretty useful tool from the Sysinternals suite. It can be considered a more advanced version of the Windows Task Manager. Process Explorer is a very powerful tool that can help us specifically identify process hollowing and masquerading techniques.
![Check the image for your reference](/Blogs/Images/image25.png)
- The above screenshot shows all the different processes running in the system in a tree format. We can also see their CPU utilization, memory usage, Process IDs (PIDs), Description, and Company name. We can enable the lower pane view from the 'View' menu to find more information about the processes. When enabled, we see the following screenshot.
![Check the image for your reference](/Blogs/Images/image26.png)
- When we select a process in the upper pane, we can see details about that process in the lower pane. Here, we see the Handles the process has opened for different Sections, Processes, Threads, Files, Mutexes, and Semaphores. Handles inform us about the resources being used in this process. If another process or a thread in another process is opened by a process, it can indicate code injection into that process. Similarly, we can see DLLs and Threads of the process in the other tabs of the lower pane.
- For some more details about a selected process, we can look at the properties of the process. We can do that by right-clicking the process name in the process tree and selecting 'Properties'. When we open the properties of a process, we see something like the below image.
![Check the image for your reference](/Blogs/Images/image27.png)
- *Process Masquerading Technique* - As seen in the below screenshot, the properties function shows us a lot of information about a process in its different tabs. Malware authors sometimes use process names similar to Windows processes or commonly used software to hide from an analyst's prying eyes. The 'Image' tab, as shown in the below screenshot, helps an analyst defeat this technique. By clicking the 'Verify' button on this tab, an analyst can identify if the executable for the running process is signed by the relevant organization, which will be Microsoft in the case of Windows binaries. In this particular screenshot, we can see that the Verify option has already been clicked. Furthermore, we can see the text '(No signature was present in the subject) Microsoft Corporation' at the top. This means that although the executable claims to be from Microsoft, it is not digitally signed by Microsoft and is masquerading as a Microsoft process. This can be an indication of a malicious process.
![Check the image for your reference](/Blogs/Images/image28.png)
- We must note here that this verification process only applies to the Image of the process stored on the disk. If a signed process has been hollowed and its code has been replaced with malicious code in the memory, we might still get a verified signature for that process. To identify hollowed processes, we have to look somewhere else.
- *Process Hollowing Technique* - Another technique used by malware to hide in plain sight is Process Hollowing. In this technique, the malware binary hollows an already running legitimate process by removing all its code from its memory and injecting malicious code in place of the legitimate code. This way, while an analyst sees a legitimate process, that process runs malicious code of the malware author. Process Explorer can help us identify this technique as well. When we open the 'Strings' tab in a process's properties, we see something like the below screenshot.
![Check the image for your reference](/Blogs/Images/image29.png)
- At the bottom of the screenshot, we can see the options 'Image' and 'Memory'. When we select 'Image', Process Explorer shows us strings present in the disk image of the process. When 'Memory' is selected, Process Explorer extracts strings from the process's memory. In normal circumstances, the strings in the Image of a process will be similar to those in the Memory as the same process is loaded in the memory. However, if a  process has been hollowed, we will see a significant difference between the strings in the Image and the process's memory. Hence showing us that the process loaded in the memory is vastly different from the process stored on the disk.

1. What is the name of the first Mutex created by the sample `~Desktop\samples\1.exe?` If there are numbers in the name of the Mutex, replace them with X.
![Check the image for your reference](/Blogs/Images/image30.png)

2. Is the file signed by a known organization? Answer with Y for Yes and N for No.
![Check the image for your reference](/Blogs/Images/image30.png)

3. Is the process in the memory the same as the process on disk? Answer with Y for Yes and N for No.
![Check the image for your reference](/Blogs/Images/image31.png)

###### Malware Investigation using Regshot

- Regshot is a tool that identifies any changes to the registry (or the file system we select). It can be used to identify what registry keys were created, deleted, or modified during our dynamic analysis by malware. Regshot works by taking snapshots of the registry before and after the execution of malware and then comparing the two snapshots to identify the differences between the two.
- When we execute Regshot, we see the following interface.
![Check the image for your reference](/Blogs/Images/image32.png)
- In this simple interface, if we select the Scan dir1 option, we can also scan for changes to the file system. However, for the sake of brevity, we will only cover registry changes. To start, we can click on the '1st shot' option. It will ask us whether to take a shot or take a shot and save. Once the 1st shot is taken, we see something like the below screenshot.
![Check the image for your reference](/Blogs/Images/image33.png)
- Now that we have saved a shot of the registry, we can execute the malware. Once we have executed the malware and are confident that it has performed its malicious activity, we take a 2nd shot. For this, we click the '2nd shot' option.
![Check the image for your reference](/Blogs/Images/image34.png)
- Now that we have both shots, we can compare them to identify the registry changes performed by the malware. We do that by clicking the 'Compare' option. We will see a summary that looks something like the below screenshot.
![Check the image for your reference](/Blogs/Images/image35.png)
- Notice that it shows Keys and Values that were added, deleted, and modified. It also shows changes to Files and Folders. We see zero changes to Folders and Files because we had disabled 'Scan dir1' while taking the shots. If we had enabled this option and provided directories to monitor, we would have seen details about filesystem changes made by the malware in our selected directories. For now, let's move on to the results of our execution. If we save the results by clicking on Compare > Output, Regshot provides us with the changes in the registry, as shown in the screenshot below.
![Check the image for your reference](/Blogs/Images/image36.png)
- One advantage that Regshot enjoys over all the other tools that it does not need to be running when we execute the malware. Some malware can check all the running processes and shut down if any analysis tool is running. When analyzing, we might often encounter malware samples that check for ProcExp, ProcMon, or API Monitor before performing any malicious activity and quitting if these processes are found. Therefore, these samples might thwart our analysis efforts. However, since Regshot takes a shot before and after the execution of the malware sample, it does not need to be running during malware execution, making it immune to this technique of detection evasion. On the flip side, we must ensure that no other process is running in the background while performing analysis with Regshot, as there is no filtering mechanism in Regshot, as we saw in the other tools. Hence, any noise created by background processes will also be recorded by Regshot, resulting in False Positives.

1. Analyze the sample `~Desktop\Samples\3.exe` using Regshot. There is a registry value added that contains the path of the sample in the format HKU\S-X-X-XX-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXX-XXX\. What is the path of that value after the format mentioned here?
![Check the image for your reference](/Blogs/Images/image37.png)
